<!DOCTYPE html>
<html>
<head>
<title>DF Material Helper</title>
<meta charset="UTF-8">
<meta http-equiv="Content-type" content="text/html; charset=UTF-8">
<script src="pixi.js"></script>
</head>
<style>
body {
    color: white;
    background-color: #0a0500;
}
a:link {
    color: #5050F0;
}
a:visited {
    color: #7F7FD0;
    
}
input[type=text] {
    background-color: #191715;
    border:solid 1px #a0a0a0;
    color: #FFF5F0;
}
input[type=number] {
    background-color: #191715;
    border:solid 1px #a0a0a0;
    color: #FFF5F0;
}
</style>
<body>
Good sources for data on materials are:<br><br>
<a href="http://www.matweb.com/index.aspx">Matweb</a><br>
<a href="http://www.wolframalpha.com/">Wolfram Alpha</a><br>
<a href="https://en.wikipedia.org/wiki/Main_Page">Wikipedia</a><br>
<a href="http://www.webelements.com/">WebElements</a><br>
If any properties are unavailable the game will use placeholders. However, if those properties happen to be one strength or elasticity, it would be best to include a placeholder value equal to that of the "nearest" material you can find; for example, if you were not able to find the Young's modulus of Iron, using Cobalt would do just fine. Some data will automatically fill out even though better data may be available; this is primarily for ease of use and can be safely ignored if all data is available. This is unlikely, however, and the placeholders will do just fine (all the vanilla materials use the same ones).<br><br>

Materials in dwarf fortress are made with the assumption that IMPACT values should be equal to COMPRESSIVE, which is incorrect; YIELD and FRACTURE should be equal to BENDING or COMPRESSIVE, whichever's less (which is always BENDING in vanilla DF). However, forcing this on whoever makes the materials would be dumb, since it is the game that we're talking about. So: <br>
Realistic IMPACT values: <input type="checkbox" id="realistic_impact" onChange="makeMat()"> <br><br>
Similarly, <a href="https://en.wikipedia.org/wiki/Von_Mises_yield_criterion#Reduced_von_Mises_equation_for_different_stress_conditions">shear stress at yield is √3 times lower than tensile stress</a> while the game considers it to be 1:1, so another checkbox: <br>
Realistic SHEAR values: <input type="checkbox" id="realistic_shear" onChange="makeMat()"><br><br>
<a href="https://en.wikipedia.org/wiki/Melting_point">Melting point</a><br>
<input type="number" id="melting_c" placeholder="1538" oninput="celciusConversion('melting')"> (celcius)<br>
<input type="number" id="melting" placeholder="2800" oninput="fahrenheitConversion('melting')"> (fahrenheit)<br>
<a href="https://en.wikipedia.org/wiki/Boiling_point">Boiling point</a><br>
<input type="number" id="boiling_c" placeholder="2862" oninput="celciusConversion('boiling')"> (celcius)<br>
<input type="number" id="boiling" placeholder="5184" oninput="fahrenheitConversion('boiling')"> (fahrenheit)<br>
<a href="https://en.wikipedia.org/wiki/Autoignition_temperature">Ignition point</a><br>
<input type="checkbox" id="ignition_point_exists" onChange="makeMat()"> Has ignition point<br>
<input type="number" id="ignition_c" placeholder="-1" oninput="celciusConversion('ignition')"> (celcius)<br>
<input type="number" id="ignition" placeholder="-1" oninput="fahrenheitConversion('ignition')"> (fahrenheit)<br>
<a href="https://en.wikipedia.org/wiki/Heat_capacity">Specific Heat</a><br>
<input type="number" id="spec_heat" placeholder="450" oninput="makeMat()"> (Joules per kilokelvin)<br>
<a href="http://dwarffortresswiki.org/index.php/DF2014:Material_definition_token">DF Values</a><br>
<input type="text" id="mat_name" placeholder="iron" oninput="makeMat()"> <a href="http://dwarffortresswiki.org/index.php/DF2014:Material_definition_token#STATE_NAME_ADJ">Name</a><br>
<input type="text" id="color" placeholder="GRAY" oninput="makeMat()"> <a href="http://dwarffortresswiki.org/index.php/DF2014:Color#Color_tokens">Color</a><br>
<input type="number" id="mat_value" placeholder="10" oninput="makeMat()"> <a href="http://dwarffortresswiki.org/index.php/DF2014:Item_value#Material_multipliers">Value</a><br>
<input type="number" id="max_edge" placeholder="10000" oninput="makeMat()"> <a href="http://dwarffortresswiki.org/index.php/DF2014:Material_definition_token#MAX_EDGE">MAX_EDGE</a><br>
<a href="https://en.wikipedia.org/wiki/Density">Density</a> (kilogram/meter<sup>3</sup>):<br>
<input type="number" id="solid_density" placeholder="7850" oninput="makeMat()"> Solid <br>
<input type="number" id="liquid_density" placeholder="6980" oninput="makeMat()"> Liquid<br>
<a href="https://en.wikipedia.org/wiki/Molar_mass">Molar mass</a><br>
<input type="number" id="molar" placeholder="55845" oninput="makeMat()"> (kg/mole)<br>
<a href="https://en.wikipedia.org/wiki/Strength_of_materials">Strength</a>:<br>
<input type="number" id="tensile_yield" placeholder="155000" oninput="makeMat()"> <a href="https://en.wikipedia.org/wiki/Yield_(engineering)">Tensile yield</a> (KPa)<br>
<input type="number" id="ultimate_tensile" placeholder="310000" oninput="makeMat()"> <a href="https://en.wikipedia.org/wiki/Ultimate_tensile_strength">Ultimate tensile strength</a> (KPa)<br>
<input type="number" id="shear_yield" placeholder="155000" oninput="makeMat()"> <a href="https://en.wikipedia.org/wiki/Yield_(engineering)">Shear yield</a> (KPa)<br>
<input type="number" id="ultimate_shear" placeholder="310000" oninput="makeMat()"> <a href="https://en.wikipedia.org/wiki/Shear_strength">Shear strength</a> (KPa)<br>
<input type="number" id="compressive_yield" placeholder="542500" oninput="makeMat()"><a href="https://en.wikipedia.org/wiki/Yield_(engineering)"> Compressive yield</a> (KPa)<br>
<input type="number" id="ultimate_compressive" placeholder="1085000" oninput="makeMat()"><a href="https://en.wikipedia.org/wiki/Compressive_strength"> Compressive strength</a> (KPa)<br>
<button onclick="strengthPlaceholders()">Fill in the rest with placeholders</button><br>
<a href="https://en.wikipedia.org/wiki/Elastic_modulus">Elastic moduli</a> (Only bulk modulus, young's modulus and shear modulus are taken into account by DF; if any cannot be found, the rest can be filled in with any two):<br>
<input type="number" id="bulk" placeholder="170000" oninput="makeMat()"> <a href="https://en.wikipedia.org/wiki/Bulk_modulus">Bulk modulus</a> (MPa)<br>
<input type="number" id="young" placeholder="211000" oninput="makeMat()"> <a href="https://en.wikipedia.org/wiki/Young%27s_modulus">Young's modulus</a> (MPa)<br>
<input type="number" id="shear" placeholder="82000" oninput="makeMat()"> <a href="https://en.wikipedia.org/wiki/Shear_modulus">Shear modulus</a> (MPa)<br>
<input type="number" id="lamé" placeholder="115000" oninput="makeMat()"> <a href="https://en.wikipedia.org/wiki/Lam%C3%A9_parameters">Lamé's First Parameter</a> (MPa) <br>
<input type="number" id="poisson" placeholder="0.293" oninput="makeMat()"> <a href="https://en.wikipedia.org/wiki/Poisson%27s_ratio">Poisson's Ratio</a> (ratio) <br>
<input type="number" id="p-wave" placeholder="279000" oninput="makeMat()"> <a href="https://en.wikipedia.org/wiki/P-wave_modulus">P-wave modulus</a> (MPa) <br>
<button onclick="convertElasticModuli()">Fill in the rest</button>


<pre id='result'></pre>

<br><br>

The below graphic depicts what the material will look like up through its breaking point. (Warning: will probably be exceedingly boring for most sufficiently strong materials) <br><p id="cur_force"></p> <p id="cur_type"></p>

<script>
//The programming proper
function getValue(id) {
    var curValue=document.getElementById(id).value
    return parseInt(curValue) ? parseInt(curValue) : parseFloat(curValue) ? parseFloat(curValue) : curValue
}

function isChecked(id) {
    return document.getElementById(id).checked
}

function getSigFig(num) {
    if (!num) {
        return num
    }
    if (Math.abs(num)>1) {
        zeroes=0
        while(Math.floor(num/Math.pow(10,zeroes))==num/Math.pow(10,zeroes)) {
            zeroes++
        }
        return Math.floor(Math.log10(num))-(zeroes-2)
    }
    else {
        trailers=0
        while(Math.floor(num*Math.pow(10,trailers))!=num*Math.pow(10,trailers)) {
            trailers++
       }
       return trailers
    }
}

function sigFigs(n, sig) { //http://blog.magnetiq.com/post/497605344/rounding-to-a-certain-significant-figures-in
    var mult = Math.pow(10,
        sig - Math.floor(Math.log(n) / Math.LN10) - 1);
    return Math.round(n * mult) / mult;
}
    
function setValue(id,value) {
    document.getElementById(id).value=value
    return id
}

function setValueInnerHTML(id,value) {
    document.getElementById(id).innerHTML=value
    return id
}

function setIfNotAlreadySet(id,value) {
    if (!getValue(id)) {
        setValue(id,value)
    }
}

function celciusConversion(nameOfThing) {
    var celcius=getValue(nameOfThing+"_c")
    setValue(nameOfThing,Math.round((1.8*celcius)+32))
    makeMat()
}
function fahrenheitConversion(nameOfThing) {
    var fahrenheit=getValue(nameOfThing)
    setValue(nameOfThing+'_c',Math.round((5*(fahrenheit-32))/9))
    makeMat()
}

function strengthPlaceholders(not_again) {
    var tensileYield=getValue('tensile_yield')
    var shearYield=getValue('shear_yield')
    var compressiveYield=getValue('compressive_yield')
    var ultimateTensile=getValue('ultimate_tensile')
    var ultimateShear=getValue('ultimate_shear')
    var ultimateCompressive=getValue('ultimate_compressive')
    var shearCoefficient = isChecked('realistic_shear') ? Math.sqrt(3) : 1
    if (tensileYield) {
        setIfNotAlreadySet('shear_yield',sigFigs(tensileYield/shearCoefficient,getSigFig(tensileYield)))
        setIfNotAlreadySet('compressive_yield',tensileYield*3.5)
        if (ultimateTensile) {
            setIfNotAlreadySet('ultimate_shear',sigFigs(ultimateTensile/shearCoefficient,getSigFig(ultimateTensile)))
            setIfNotAlreadySet('ultimate_compressive',ultimateTensile*3.5)
        }
        else {        
            setIfNotAlreadySet('ultimate_tensile',tensileYield*2)
            setIfNotAlreadySet('ultimate_shear',getValue('shear_yield')*2)
            setIfNotAlreadySet('ultimate_compressive',tensileYield*7)
        }
    }
    else if (shearYield) {
        setIfNotAlreadySet('tensile_yield',sigFigs(shearYield*shearCoefficient,getSigFig(shearYield)))
    }
    else if (compressiveYield) {
        setIfNotAlreadySet('tensile_yield',compressiveYield/3.5)
    }
    else if (ultimateTensile) {
        setIfNotAlreadySet('tensile_yield',ultimateTensile/2)
    }
    else if (ultimateShear) {
        setIfNotAlreadySet('tensile_yield',sigFigs(ultimateShear*(shearCoefficient/2),getSigFig(ultimateShear)))
    }
    else if (ultimateCompressive) {
        setIfNotAlreadySet('tensile_yield',ultimateCompressive/7)
    }
    if (!not_again) {
        strengthPlaceholders(true)
    }
    makeMat()
}

function convertElasticModuli() {
    var K=getValue("bulk") //silly variable names primarily to make math slightly more readable
    var E=getValue("young") //also because that's actually how they're usually notated
    var L=getValue("lamé") //technically should be lambda but ILLEGAL
    var G=getValue("shear") 
    var v=getValue("poisson") //okay so technically it should be ν but I'm not that evil
    var M=getValue("p-wave")
    if (K) {
        if (E) {
            var sigfig=Math.min(getSigFig(K),getSigFig(E))
            setValue("lamé",sigFigs((3*K*(3*K-E))/(9*K-E),sigfig))
            setValue("shear",sigFigs((3*K*E)/(9*K-E),sigfig))
            setValue("poisson",sigFigs((3*K-E)/(6*K),sigfig))
            setValue("p-wave",sigFigs((3*K*(3*K+E))/(9*K-E),sigfig))
        }
        else if (L) {
            var sigfig=Math.min(getSigFig(K),getSigFig(L))
            setValue("young",sigFigs((9*K*(K-L))/(3*K-L),sigfig))
            setValue("shear",sigFigs((3*(K-L))/2,sigfig))
            setValue("poisson",sigFigs(L/(3*K-L),sigfig))
            setValue("p-wave",sigFigs(3*K-2*L,sigfig))
        }
        else if (G) {
            var sigfig=Math.min(getSigFig(K),getSigFig(G))
            setValue("young",sigFigs((9*K*G)/(3*K+G),sigfig))
            setValue("lamé",sigFigs(K-((2*G)/3),sigfig))
            setValue("poisson",sigFigs((3*K-2*g)/(2*(3*K+G)),sigfig))
            setValue("p-wave",sigFigs(K+((4*G)/3),sigfig))
        }
        else if (v) {
            var sigfig=Math.min(getSigFig(K),getSigFig(v))
            setValue("young",sigFigs(3*K*(1-2*v),sigfig))
            setValue("lamé",sigFigs((3*K*v)/(1+v),sigfig))
            setValue("shear",sigFigs((3*K*(1-2*v))/(2*(1+v)),sigfig))
            setValue("p-wave",sigFigs((3*K*(1-v))/(1+v),sigfig))
        }
        else if (M) {
            var sigfig=Math.min(getSigFig(K),getSigFig(M))
            setValue("young",sigFigs((9*K*(M-K))/(3*K+M),sigfig))
            setValue("lamé",sigFigs((3*K-M)/2,sigfig))
            setValue("shear",sigFigs((3*(M-K))/4,sigfig))
            setValue("poisson",sigFigs((3*K-M)/(3*K+M),sigfig))
        }
    }
    else if (E) {
        if (L) {
            var sigfig=Math.min(getSigFig(E),getSigFig(L))
            var R=Math.sqrt(Math.pow(E,2)+9*Math.pow(L,2)+2*E*L)
            setValue("bulk",sigFigs((E+3*L+R)/6,sigfig))
            setValue("shear",sigFigs((E-3*L+R)/4,sigfig))
            setValue("poisson",sigFigs((2*L)/(E+L+R),sigfig))
            setValue("p-wave",sigFigs((E-L+R)/2,sigfig))
        }
        else if (G) {
            var sigfig=Math.min(getSigFig(E),getSigFig(G))
            setValue("bulk",sigFigs((E*G)/(3*(3*G-E)),sigfig))
            setValue("lamé",sigFigs((G*(E-2*G))/(3*G-E),sigfig))
            setValue("poisson",sigFigs((E/(2*G))-1,sigfig))
            setValue("p-wave",sigFigs((G*(4*G-E))/(3*G-E),sigfig))
        }
        else if (v) {
            var sigfig=Math.min(getSigFig(E),getSigFig(v))
            setValue("bulk",sigFigs(E/(3*(1-2*v)),sigfig))
            setValue("lamé",sigFigs((E*v)/((1+v)*(1-2*v)),sigfig))
            setValue("shear",sigFigs(E/(2*(1+v)),sigfig))
            setValue("p-wave",sigFigs((E*(1-v))/((1+v)*(1-2*v)),sigfig))
        }
        else if (M) {
            var sigfig=Math.min(getSigFig(E),getSigFig(M))
            var S=Math.sqrt(Math.pow(E,2)+9*Math.pow(M,2)-10*E*M)
            setValue("bulk",sigFigs((3*M-E+S)/6,sigfig))
            setValue("lamé",sigFigs((M-E+S)/4,sigfig))
            setValue("shear",sigFigs((3*M+E-S)/8,sigfig))
            setValue("poisson",sigFigs((E-M+S)/(4*M),sigfig))
        }
    }
    else if (L) {
        if (G){
            var sigfig=Math.min(getSigFig(L),getSigFig(G))
            setValue("bulk",sigFigs(L+((2*G)/3),sigfig))
            setValue("young",sigFigs((G*(3*L+2*G))/(L+G),sigfig))
            setValue("poisson",sigFigs(L/(2*(L+G)),sigfig))
            setValue("p-wave",sigFigs((L*(1-v))/v,sigfig))
        }
        else if (v){
            var sigfig=Math.min(getSigFig(L),getSigFig(v))
            setValue("bulk",sigFigs((L*(1+v))/(3*v),sigfig))
            setValue("young",sigFigs((L*(1+v)*(1-2*v))/v,sigfig))
            setValue("shear",sigFigs((L*(1-2*v))/(2*v),sigfig))
            setValue("p-wave",sigFigs((L*(1-v))/v,sigfig))
        }
        else if (M){
            var sigfig=Math.min(getSigFig(L),getSigFig(M))
            setValue("bulk",sigFigs((M+2*L)/3,sigfig))
            setValue("young",sigFigs(((M-L)*(M+2*L))/(M+L),sigfig))
            setValue("shear",sigFigs((M-L)/2,sigfig))
            setValue("poisson",sigFigs(L/(M+L),sigfig))
        }
    }
    else if (G) {
        if (v){
            var sigfig=Math.min(getSigFig(G),getSigFig(v))
            setValue("bulk",sigFigs((2*G*(1+v))/(3*(1-2*v)),sigfig))
            setValue("young",sigFigs(2*G*(1+v),sigfig))
            setValue("lamé",sigFigs((2*G*v)/(1-2*v),sigfig))
            setValue("p-wave",sigFigs((2*G*(1-v))/(1-2*v),sigfig))
            }
        else if (M){
            var sigfig=Math.min(getSigFig(G),getSigFig(M))
            setValue("bulk",sigFigs(M-((4*G)/3),sigfig))
            setValue("young",sigFigs((G*(3*M-4*G))/(M-G),sigfig))
            setValue("lamé",sigFigs(M-2*G,sigfig))
            setValue("poisson",sigFigs((M-2*G)/(2*M-2*G),sigfig))
        }
    }
    else if (v) {
        if (M) {
            var sigfig=Math.min(getSigFig(v),getSigFig(M))
            setValue("bulk",sigFigs((M*(1+v))/(3*(1-v)),sigfig))
            setValue("young",sigFigs((M*(1+v)*(1-2*v))/(1-v),sigfig))
            setValue("lamé",sigFigs((M*v)/(1-v),sigfig))
            setValue("shear",sigFigs((M*(1-2*v))/(2*(1-v)),sigfig))
        }
    }
    makeMat()
}

function tempName(state) {
    switch(state) {
        case 'solid':
            if (getValue('melting')<64) {
                return 'frozen '+getValue('mat_name')
            } else {
                return getValue('mat_name')
            }
            break;
        case 'liquid':
            if (getValue('melting')>64) {
                return 'molten '+getValue('mat_name')
            } else {
                return getValue('mat_name')
            }
            break;
        case 'gas':
            if (getValue('boiling')>64) {
                return 'boiling '+getValue('mat_name')
            } else {
                return getValue('mat_name')
            }
            break;
        default:
            break;
    }
}
function makeMat() {
    var young=Math.round(getValue('tensile_yield')*100/(getValue('young')))
    var bulk=Math.round((100*getValue('compressive_yield'))/(getValue('bulk')))
    var shear=Math.round((100*getValue('shear_yield'))/(getValue('shear')))
    var tensileYield=getValue('tensile_yield')
    var compressiveYield=getValue('compressive_yield')
    var shearYield=getValue('shear_yield')
    var ultimateTensile=getValue('ultimate_tensile')
    var ultimateCompressive=getValue('ultimate_compressive')
    var ultimateShear=getValue('ultimate_shear')
    var impactYield=isChecked('realistic_impact') ? Math.min(tensileYield,compressiveYield) : compressiveYield
    var impactFracture=isChecked('realistic_impact') ? Math.min(ultimateTensile,ultimateCompressive) : ultimateCompressive
    var bendingYield=Math.min(tensileYield,compressiveYield)
    var bendingFracture=Math.min(ultimateTensile,ultimateCompressive)
    var holyCrapABigStringOne="    [STATE_NAME_ADJ:ALL_SOLID:"+tempName('solid')+"]\n" + //would you believe that this whole segment was copied from python and only minorly edited?
                "    [STATE_NAME_ADJ:LIQUID:"+tempName('liquid')+"]\n" + 
                "    [STATE_NAME_ADJ:GAS:"+tempName('gas')+"]\n" +
                "    [DISPLAY_COLOR:0:7:1]\n" +
                "    [BUILD_COLOR:0:7:1]\n" +
                "    [MATERIAL_VALUE:"+getValue('mat_value')+"]\n" +
                "    [SPEC_HEAT:"+getValue('spec_heat')+"]\n" +
                "    [MELTING_POINT:"+(getValue('melting')+9968)+"]\n" +
                "    [BOILING_POINT:"+(getValue('boiling')+9968)+"]\n"
    var holyCrapABigStringTwo="    [SOLID_DENSITY:"+getValue('solid_density')+"]\n" +
                "    [LIQUID_DENSITY:"+getValue('liquid_density')+"]\n" +
                "    [MOLAR_MASS:"+getValue('molar')+"]\n" +
                "    [IMPACT_YIELD:"+impactYield+"]\n" +
	            "    [IMPACT_FRACTURE:"+impactFracture+"]\n" +
	            "    [IMPACT_STRAIN_AT_YIELD:"+bulk+"]\n" +
	            "    [COMPRESSIVE_YIELD:"+compressiveYield+"]\n" +
	            "    [COMPRESSIVE_FRACTURE:"+ultimateCompressive+"]\n" +
	            "    [COMPRESSIVE_STRAIN_AT_YIELD:"+bulk+"] bulk modulus "+ getValue('bulk')/1000 + " GPa\n" +
	            "    [TENSILE_YIELD:"+tensileYield+"]\n" +
	            "    [TENSILE_FRACTURE:"+ultimateTensile+"]\n" +
	            "    [TENSILE_STRAIN_AT_YIELD:"+young+"] young's modulus "+ getValue('young')/1000 + " GPa\n" +
	            "    [TORSION_YIELD:"+shearYield+"]\n" +
	            "    [TORSION_FRACTURE:"+ultimateShear+"]\n" +
                "    [TORSION_STRAIN_AT_YIELD:"+shear+"]\n" +
	            "    [SHEAR_YIELD:"+shearYield+"]\n" +
	            "    [SHEAR_FRACTURE:"+ultimateShear+"]\n" +
	            "    [SHEAR_STRAIN_AT_YIELD:"+shear+"] shear modulus " +getValue('shear')/1000+ " GPa\n" +
	            "    [BENDING_YIELD:"+bendingYield+"]\n" +
	            "    [BENDING_FRACTURE:"+bendingFracture+"]\n" +
	            "    [BENDING_STRAIN_AT_YIELD:"+young+"]\n" +
	            "    [MAX_EDGE:"+getValue("max_edge")+"]\n" +
                "    [STATE_COLOR:ALL:"+getValue('color')+"]"
    var igniteString=(!isChecked("ignition_point_exists")) ? "" : ("    [IGNITE_POINT:"+(getValue('ignition')+9968+"]\n"))
    setValueInnerHTML('result',holyCrapABigStringOne+igniteString+holyCrapABigStringTwo)
}

//Google analytics code snippet
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61577221-1', 'auto');
  ga('send', 'pageview');

//rendering stuff

var mat_shower = mat_shower || {}

mat_shower.stage=new PIXI.Stage(0x0a0500,true)
mat_shower.renderer=PIXI.autoDetectRenderer(500, 400)
mat_shower.graphics=new PIXI.Graphics()
mat_shower.stage.addChild(mat_shower.graphics)
mat_shower.forces=[0,0,0] //tensile, shear, compression, all in kilopascals
mat_shower.mode=1
mat_shower.step=1000000
document.body.appendChild(mat_shower.renderer.view)

requestAnimFrame( animate );

function calculateForceDeformation() {
    var deformation=0
    if (mat_shower.forces[0]>0){
        strain_at_yield=Math.round((getValue('tensile_yield')*100)/getValue('young'))
        deformation=(mat_shower.forces[0]/getValue('tensile_yield'))*(strain_at_yield/50000)
    }
    else if (mat_shower.forces[1]>0){
        strain_at_yield=Math.round((100*getValue('compressive_yield'))/(getValue('bulk')))
        deformation=-(mat_shower.forces[1]/getValue('compressive_yield'))*(strain_at_yield/50000)
    } else {
        strain_at_yield=Math.round((100*getValue('shear_yield'))/(getValue('shear')))
        deformation=(mat_shower.forces[2]/getValue('shear_yield'))*(strain_at_yield/50000)
    }
    return deformation*100
}

function animate() {
    mat_shower.graphics.clear()
    if (mat_shower.forces[0]>getValue('ultimate_tensile')) {
        mat_shower.forces[0]=0
        mat_shower.mode=1
        mat_shower.step=Math.floor(getValue('ultimate_compressive')/100)
        setTimeout(function() {requestAnimFrame( animate )}, 100)
    }
    else if (mat_shower.forces[1]>getValue('ultimate_compressive')) {
        mat_shower.forces[1]=0
        mat_shower.mode=2
        mat_shower.step=Math.floor(getValue('ultimate_tensile')/100)
        setTimeout(function() {requestAnimFrame( animate )}, 100)
    } 
    else if (mat_shower.forces[2]>getValue('ultimate_shear')) {
        mat_shower.forces[2]=0
        mat_shower.mode=0
        mat_shower.step=Math.floor(getValue('ultimate_shear')/100)
        setTimeout(function() {requestAnimFrame( animate )}, 100)
    }
    else if (mat_shower.step<1) {
        mat_shower.step=1000000
        setTimeout(function() {requestAnimFrame( animate )}, 100)
    } 
    else if (!getValue('bulk') || !getValue('young') || !getValue('compressive_yield') || !getValue('tensile_yield')) {
        setTimeout(function() {requestAnimFrame( animate )}, 100)
    }
    else if (mat_shower.mode==0 || mat_shower.mode==1) {
        var deformation=calculateForceDeformation()
        var poisson=getValue('poisson')
        var ends=[100-deformation,250+deformation]
        var middles=[100+(deformation*poisson),200-(deformation*poisson)]
        if (ends[0]>ends[1]) {
            setValue('ultimate_compressive',mat_shower.forces[1])
            makeMat()
            setTimeout(function() {requestAnimFrame( animate )}, 100)
            mat_shower.forces[1]=0
            mat_shower.mode=2
            mat_shower.step=Math.floor(getValue('ultimate_shear')/100)
            return
        }
        if (middles[0]>middles[1]) {
            setValue('ultimate_tensile',mat_shower.forces[0])
            makeMat()
            mat_shower.forces[0]=0
            mat_shower.mode=1
            mat_shower.step=Math.floor(getValue('ultimate_compressive')/100)
            setTimeout(function() {requestAnimFrame( animate )}, 100)
            return
        }
        mat_shower.graphics.beginFill(0xa6a6a6)
        mat_shower.graphics.moveTo(100,ends[0])
        mat_shower.graphics.bezierCurveTo(100,ends[0],middles[0],200,100,ends[1])
        mat_shower.graphics.lineTo(200,ends[1])
        mat_shower.graphics.bezierCurveTo(200,ends[1],middles[1],200,200,ends[0])
        mat_shower.graphics.lineTo(100,ends[0])
        // render the stage   
        mat_shower.renderer.render(mat_shower.stage)
        mat_shower.forces[mat_shower.mode]+=mat_shower.step
        setValueInnerHTML('cur_force',mat_shower.mode==0 ? mat_shower.forces[0] + ' kilopascals' : mat_shower.forces[1] + ' kilopascals')
        setValueInnerHTML('cur_type',mat_shower.mode==0 ? 'Tensile force' : 'Compressive force')
        setTimeout(function() {requestAnimFrame( animate )}, 100)
    } else {
        var deformation=calculateForceDeformation()
        var ends=[100+deformation,200+deformation]
        mat_shower.graphics.beginFill(0xa6a6a6)
        mat_shower.graphics.moveTo(100,250)
        mat_shower.graphics.lineTo(ends[0],100)
        mat_shower.graphics.lineTo(ends[1],100)
        mat_shower.graphics.lineTo(200,250)
        // render the stage   
        mat_shower.renderer.render(mat_shower.stage)
        mat_shower.forces[mat_shower.mode]+=mat_shower.step
        setValueInnerHTML('cur_force',mat_shower.forces[2] + ' kilopascals')
        setValueInnerHTML('cur_type','Shear force')
        setTimeout(function() {requestAnimFrame( animate )}, 100)
    }
}

</script>

</body>
</html