<!DOCTYPE html>
<html>
<head>
<title>DF Material Helper</title>
<meta charset="UTF-8">
<meta http-equiv="Content-type" content="text/html; charset=UTF-8">
<link rel="stylesheet" type="text/css" href="style.css">
<meta name=viewport content="width=device-width, initial-scale=1">
<meta name="description" content="Undertale tile maze">

</head>
<body>
this doesn't work yet, it just happens to require being on the internet to test
    <input type="number" id="maze_height" value="6" tabindex=1 >
    <input type="number" id="maze_width" value="8" tabindex=2 >
    <button tabindex=3 onclick="maze.generate()">Generate a maze</button><br>
    <script src="pixi.min.js"></script>
    <script>
        function Position(x,y) {
            if (isNaN(x)) {x=0}
            if (isNaN(y)) {y=0}
            this.x=Math.floor(x)
            this.y=Math.floor(y)
            this.add=function(otherPos) {
                return new Position(this.x+otherPos.x,this.y+otherPos.y)
            }
            this.subtract=function(otherPos) {
                return new Position(this.x-otherPos.x,this.y-otherPos.y)
            }
            this.negate=function() {
                return new Position(0-this.x,0-this.y)
            }
            this.equals=function(otherPos) {
                return (otherPos.x==this.x && otherPos.y==this.y)
            }
            this.toString=function() {
                return '('+this.x+','+this.y+')'
            }
            this.copy=function() {
                return new Position(this.x,this.y)
            }
            this.normalize=function() {
                var divisor=(Math.abs(x)>Math.abs(y)) ? x : y
                return new Position(Math.floor(this.x/divisor),Math.floor(this.y/divisor))
            }
        }
        function FakeStepper(pos) {
            this.pos = new Position(pos)
            this.setPos=function(pos) {
                this.pos.x=pos.x
                this.pos.y=pos.y
                return this.pos
            }
            this.getPos=function() {
                return this.pos
            }
            this.setScent=function(scent) {
                self.scent=scent
                return this.scent
            }
            this.getScent=function() {
                return this.scent
            }
        }

        function Player(pos) {
            this.pos = new Position(pos)
            this.sprite=new PIXI.Sprite.fromImage('character.png')
            maze.graphics.characters.addChild(this.sprite)
            maze.graphics.renderer.render(maze.graphics.stage)
            this.setPos=function(pos) {
                this.pos.x=pos.x
                this.pos.y=pos.y
                this.sprite.x=pos.x*16
                this.sprite.y=pos.y*16
                maze.graphics.renderer.render(maze.graphics.stage)
                return this.pos
            }
            this.getPos=function() {
                return this.pos
            }
            this.setScent=function(scent) {
                self.scent=scent
                return this.scent
            }
            this.getScent=function() {
                return this.scent
            }
            this.move=function(x,y) {
                maze.getTileAtPos(this.pos.add(new Position(x,y))).on_step(this)
            }
        }
        function PathBot(pos) {
            this.pos = new Position(pos)
            this.discoveredPositions={}
            for (x=0;x<maze.width;x++) {
                this.discoveredPositions[x]={}
                for (y=0;y<maze.height;y++) {
                    this.discoveredPositions[x][y]=false
                }
            }
            this.setPos=function(pos) {
                this.pos.x=pos.x
                this.pos.y=pos.y
                return this.pos
            }
            this.getPos=function() {
                if (isNaN(this.pos.x) || isNaN(this.pos.y)) {
                    this.pos=new Position(0,2)
                }
                return this.pos
            }
            this.setScent=function(scent) {
                this.scent=scent
                return this.scent
            }
            this.getScent=function() {
                return this.scent
            }
            this.searchTilePath=function(tile) {
                if (!pos in tile) { return false }
                this.discoveredPositions[tile.pos.x][tile.pos.y]=true
                if (tile.pos.x==maze.width-1) {
                    return false
                }
                var adjacentTiles=maze.getAdjacentTiles(tile.pos)
                for (idx in adjacentTiles) {
                    var newtile=adjacentTiles[idx]
                    if (typeof(newtile)!='undefined' && !this.discoveredPositions[newtile.pos.x][newtile.pos.y]) {
                        var steppable=newtile.on_step(this)
                        if (steppable) {
                            return this.searchTilePath(newtile)
                        }
                    }
                }
                if (!tile.on_step(this)) { //would only happen if orange-scented and going back to blue tile; depth-first search isn't so much backtracking in this case as resetting time to previous, heh
                    this.setScent('lemon')
                }
                tile.on_step(this)
                return true
            }
            
        }
        function Tile(tileType,pos) {
            switch(tileType) {
                case "red": 
                    this.color=0xdf3005
                    this.on_step=function(stepper) {
                        return false
                    }
                    this.is_pathable_from_purple=function(stepper) {
                        return false
                    }
                    break
                case "yellow":
                    this.color=0xe9e400
                    this.on_step=function(stepper) {
                        return false
                    }
                    this.is_pathable_from_purple=function() { return false }
                    break
                case "green":
                    this.color=0x18c400
                    this.on_step=function(stepper) {
                        stepper.setPos(this.pos) //yeah, movement is handled by the tile object, it's not a complex game
                        return true
                    }
                    this.is_pathable_from_purple=function() {
                        return true
                    }
                    break
                case "orange":
                    this.color=0xe4a338
                    this.on_step=function(stepper) {
                        stepper.setPos(this.pos)
                        stepper.setScent('orange')
                        return true
                    }
                    this.is_pathable_from_purple=function() {
                        return true
                    }
                    break
                case "blue":
                    this.color=0x1118ff
                    this.on_step=function(stepper) {
                        if (stepper.getScent()!='orange') {
                            for (tile in maze.getAdjacentTiles(this.pos)) {
                                if (tile.type=='yellow') {
                                    return false
                                }
                            }
                            stepper.setPos(this.pos)
                            return true
                        }
                        return false
                    }
                    this.is_pathable_from_purple=function(stepper) {
                        for (tile in maze.getAdjacentTiles(this.pos)) {
                            if (tile.type=='yellow') {
                                return false
                            }
                        }
                        return true
                    }
                    break
                case "purple":
                    this.color=0x792387
                    this.on_step=function(stepper) {
                        stepper.setScent('lemon')
                        var direction=this.pos.subtract(stepper.getPos()).normalize()
                        var newTile=maze.getTileAtPos(this.pos.add(direction))
                        if (newTile.is_pathable_from_purple(direction)) {
                            stepper.setPos(this.pos)
                            newTile.on_step(stepper)
                        }
                    }
                    this.is_pathable_from_purple=function(direction) {
                        return maze.getTileAtPos(this.pos.add(direction)).is_pathable_from_purple(direction)
                    }
                    break
                default: //will count for pink
                    this.color=0xe47a60
                    this.on_step=function(stepper) {
                        stepper.setPos(this.pos)
                        return true
                    }
                    this.is_pathable_from_purple=function() { return true }
                    break
            }
            this.type=tileType
            this.pos=pos || new Position(-1,-1)
            this.render=function(graphics) {
                graphics.beginFill(this.color)
                graphics.lineStyle(0,this.color,0)
                graphics.drawRect(this.pos.x*16,this.pos.y*16,16,16)
            }
            this.on_step=this.on_step || function(stepper) {
                stepper.setPos(this.pos)
                return true
            }
        }
        var maze=maze || {}
        maze.graphics=maze.graphics || {}
        maze.graphics.stage=new PIXI.Container()
        maze.graphics.world=new PIXI.Container()
        maze.graphics.characters=new PIXI.Container()
        maze.graphics.characters.z=2
        maze.graphics.world.z=1
        maze.graphics.stage.addChild(maze.graphics.world);
        maze.graphics.stage.addChild(maze.graphics.characters);
        maze.graphics.stage.children.sort(function(a,b) { if (a.z<b.z) {return -1} else if (a.z > b.z) { return 1 } else return 0 })
        maze.graphics.stage.interactive=true
        maze.graphics.renderer=PIXI.autoDetectRenderer(800,600)
        maze.graphics.renderer.backgroundColor=0x0a0500
        maze.graphics.drawer=new PIXI.Graphics()
        maze.graphics.world.addChild(maze.graphics.drawer)
        document.body.appendChild(maze.graphics.renderer.view)
        maze.graphics.renderer.render(maze.graphics.stage)
        maze.tiles={}
        maze.width=8
        maze.height=6
        maze.getTileAtPos=function(pos) {
            if (isNaN(pos.x) || isNaN(pos.y) || pos.x<0 || pos.y<0 || pos.x>=this.width || pos.y>=this.height) {
                return new Tile('red',pos)
            } else {
                var tile=this.tiles[pos.x][pos.y]
                if (typeof(tile)=='undefined') {
                    return new Tile('red',pos)
                }
                return tile
            }
        }
        maze.getTile=function(x,y) {
            if (x<0 || y<0 || x>=this.width || y>=this.height) {
                return Tile('red',new Position(x,y))
            } else {
                return this.tiles[x][y]
            }
        }
        maze.getAdjacentTiles=function(pos) {
            return [this.getTile(pos.x-1,pos.y),this.getTile(pos.x+1,pos.y),this.getTile(pos.x,pos.y-1),this.getTile(pos.x,pos.y+1)]
        }
        maze.generate=function() {
            this.width=Math.max(parseInt(document.getElementById('maze_width').value),3)
            this.height=Math.max(parseInt(document.getElementById('maze_height').value),3)
            this.player={}
            this.controllable=false
            this.graphics.characters=new PIXI.Container()
            var tileTypes=["red","yellow","green","orange","blue","purple","pink"]
            var safeTiles=["red","yellow","green","orange","blue","pink"]
            this.tiles = {}
            for (x=0;x<this.width;x++) {
                this.tiles[x]={}
                for (y=0;y<this.height;y++) {
                    if (x==this.width-1 || y==this.height-1 || x==0 || y==0)
                    {
                        this.tiles[x][y]=new Tile(safeTiles[Math.floor(Math.random() * 6)],new Position(x,y))
                    } else {
                        this.tiles[x][y]=new Tile(tileTypes[Math.floor(Math.random() * 7)],new Position(x,y))
                    }
                }
            }
            this.render()
            this.tiles[0][2]=new Tile('pink',new Position(0,2))
            if (this.isUnpathable()) {
                setTimeout(function() {maze.generate()},100)
            } else {
                this.player=new Player(new Position(0,2))
                this.controllable=true
                this.render()
            }
        }
        maze.isUnpathable=function() {
            var startPos=new Position(0,2)
            new Position(0,Math.floor(this.height/2))
            var stepper=new PathBot(startPos)
            var solvable=stepper.searchTilePath(maze.getTile(startPos.x,startPos.y))
            return solvable
        }
        maze.render=function() {
            this.graphics.drawer.clear()
            for (column in this.tiles) {
                var realColumn=this.tiles[column]
                for (tile in realColumn) {
                    var realTile=realColumn[tile]
                    realTile.render(this.graphics.drawer)
                }
            }
            maze.graphics.renderer.render(maze.graphics.stage)
        }
        document.onkeydown=function(e) {
            if (maze.controllable) {
                switch(e.keyCode) {
                    case 37: 
                        e.preventDefault()
                        maze.player.move(-1,0)
                        break
                    case 38:
                        e.preventDefault()
                        maze.player.move(0,-1)
                        break
                    case 39:
                        e.preventDefault()
                        maze.player.move(1,0)
                        break
                    case 40:
                        e.preventDefault()
                        maze.player.move(0,1)
                        break
                }
            }
        }
    </script>
</body>